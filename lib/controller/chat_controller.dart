import 'dart:convert';
import 'dart:io';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:crypto/crypto.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:get_storage/get_storage.dart';
import 'package:hive/hive.dart';
import 'package:image_cropper/image_cropper.dart';
import 'package:image_picker/image_picker.dart';
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:flutter_image_compress/flutter_image_compress.dart';
import 'package:video_thumbnail/video_thumbnail.dart';
import '../models/message_model.dart';
import '../services/video_thumbnail_cache.dart';
import 'notification_controller.dart';

class ChatController extends GetxController {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseStorage _storage = FirebaseStorage.instance;
  final box = GetStorage();
  final ImagePicker _picker = ImagePicker();

  // ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ
  var messages = <MessageModel>[].obs;


  Future<Box<MessageModel>> openChatBox(String chatId) async {
    final dir = await getApplicationDocumentsDirectory();
    Hive.init(dir.path);
    return await Hive.openBox<MessageModel>('chat_$chatId');
  }

  Future<List<MessageModel>> getCachedMessages(String senderId, String receiverId) async {
    final chatBox = await openChatBox(_chatKey(senderId, receiverId));
    return chatBox.values.toList().cast<MessageModel>();
  }

  // final Map<String, String> senderImageCache = {};

  Future<String> getSenderImage(String senderId) async {
    if (senderImageCache.containsKey(senderId)) {
      return senderImageCache[senderId]!;
    }

    final snapshot = await FirebaseFirestore.instance.collection('users').doc(senderId).get();
    final imageUrl = snapshot.data()?['profileImageUrl'] ?? 'https://i.pravatar.cc/150?u=$senderId';
    senderImageCache[senderId] = imageUrl;
    return imageUrl;
  }

  final Map<String, String> senderImageCache = {};

  Future<void> preloadSenderImages(List<MessageModel> messages) async {
    for (final msg in messages) {
      if (!senderImageCache.containsKey(msg.senderId)) {
        try {
          final snapshot = await FirebaseFirestore.instance
              .collection('users')
              .doc(msg.senderId)
              .get();

          final imageUrl = snapshot.data()?['profileImageUrl'] ??
              'https://i.pravatar.cc/150?u=${msg.senderId}';

          senderImageCache[msg.senderId] = imageUrl;
        } catch (e) {
          print("‚ö†Ô∏è Error loading image for ${msg.senderId}: $e");
        }
      }
    }
  }


  Stream<List<MessageModel>> getMessages(String senderId, String receiverId) {
    return _firestore
        .collection('users')
        .doc(senderId)
        .collection('chats')
        .doc(receiverId)
        .collection('messages')
        .orderBy('timestamp')
        .snapshots()
        .map((snapshot) {
      final newMessages = snapshot.docs
          .map((doc) => MessageModel.fromMap(doc.data(), docId: doc.id))
          .toList();
      messages.assignAll(newMessages);
      return newMessages;
    });
  }

  String _chatKey(String senderId, String receiverId) {
    return senderId.compareTo(receiverId) <= 0
        ? '${senderId}_$receiverId'
        : '${receiverId}_$senderId';
  }




  // ‚úÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ŸÜÿµŸäÿ© ÿ£Ÿà Ÿàÿ≥ÿßÿ¶ÿ∑
  Future<void> sendMessage(
      String senderId,
      String receiverId,
      String content,
      String contentType, {
        String? replyToStoryUrl,
        String? replyToStoryType,
        String? replyToStoryId,
        String? localPath,
      }) async {
    try {
      String senderName = box.read('fullName') ?? 'Unknown Sender';
      String senderUsername = box.read('username') ?? 'UnknownUsername';
      String senderImage = box.read('profileImageUrl') ?? '';

      String? receiverName = box.read('receiverName_$receiverId');
      String? receiverUsername = box.read('receiverUsername_$receiverId');
      String? receiverImage = box.read('receiverImage_$receiverId');

      if (receiverName == null || receiverUsername == null || receiverImage == null) {
        DocumentSnapshot receiverDoc = await _firestore.collection('users').doc(receiverId).get();
        if (receiverDoc.exists) {
          Map<String, dynamic>? receiverData = receiverDoc.data() as Map<String, dynamic>?;
          receiverName = receiverData?['fullName'] ?? 'Unknown Receiver';
          receiverUsername = receiverData?['username'] ?? 'UnknownUsername';
          receiverImage = receiverData?['profileImageUrl'] ?? '';

          box.write('receiverName_$receiverId', receiverName);
          box.write('receiverUsername_$receiverId', receiverUsername);
          box.write('receiverImage_$receiverId', receiverImage);
        }
      }

      String messageId = _firestore.collection('messages').doc().id;
      final provisionalTimestamp = DateTime.now();

      MessageModel message = MessageModel(
        id: messageId,
        senderId: senderId,
        receiverId: receiverId,
        content: content,
        contentType: contentType,
        isRead: false,
        timestamp: provisionalTimestamp,
        receiverName: receiverName ?? 'Unknown Receiver',
        receiverUsername: receiverUsername ?? 'UnknownUsername',
        replyToStoryUrl: replyToStoryUrl,
        replyToStoryType: replyToStoryType,
        replyToStoryId: replyToStoryId,
        localPath: localPath,
      );

      final messageData = message.toMap(useServerTimestamp: true);

      // Add to sender's Firestore
      await _firestore
          .collection('users')
          .doc(senderId)
          .collection('chats')
          .doc(receiverId)
          .collection('messages')
          .add(messageData);

      // Add to receiver's Firestore
      await _firestore
          .collection('users')
          .doc(receiverId)
          .collection('chats')
          .doc(senderId)
          .collection('messages')
          .add(messageData);

      final receiverChatRef = _firestore
          .collection('users')
          .doc(receiverId)
          .collection('chats')
          .doc(senderId);

      final lastMessagePreview = switch (contentType) {
        'image' => 'Image üñºÔ∏è',
        'video' => 'Video üé•',
        'audio' => 'Audio üéµ',
        _ => content,
      };

      await _firestore.runTransaction((transaction) async {
        final receiverChatSnapshot = await transaction.get(receiverChatRef);
        int currentUnreadMessages = receiverChatSnapshot.exists
            ? receiverChatSnapshot.get('unreadMessages') ?? 0
            : 0;

        transaction.set(receiverChatRef, {
          'lastMessage': lastMessagePreview,
          'timestamp': FieldValue.serverTimestamp(),
          'receiverName': senderName,
          'receiverUsername': senderUsername,
          'receiverImage': senderImage,
          'unreadMessages': currentUnreadMessages + 1,
        }, SetOptions(merge: true));
      });

      final senderChatRef = _firestore
          .collection('users')
          .doc(senderId)
          .collection('chats')
          .doc(receiverId);

      await senderChatRef.set({
        'lastMessage': lastMessagePreview,
        'timestamp': FieldValue.serverTimestamp(),
        'receiverName': receiverName,
        'receiverUsername': receiverUsername,
        'receiverImage': receiverImage,
        'unreadMessages': 0,
      }, SetOptions(merge: true));

      // Send push notification (v1)
      final receiverDoc = await _firestore.collection('users').doc(receiverId).get();
      final receiverFcmToken = receiverDoc.data()?['fcmToken'];

      if (receiverFcmToken != null && receiverFcmToken.isNotEmpty) {
        await NotificationController.sendPushNotificationV1(
          token: receiverFcmToken,
          title: senderName,
          body: lastMessagePreview,
        );
        print('‚úÖ Notification sent successfully to $receiverUsername');
      }
    } catch (e) {
      print("‚ùå Error sending message: $e");
    }
  }



  void listenToMessages(String senderId, String receiverId) {
    getMessages(senderId, receiverId).listen((msgList) {
      messages.assignAll(msgList);
    });
  }


  Future<void> deleteMessageLocally(String messageId, String receiverId) async {
    try {
      final String senderId = box.read('user_id');

      // ÿ≠ÿ∞ŸÅ ŸÖŸÜ Firestore (ŸÅŸÇÿ∑ ŸÖŸÜ ŸÖÿ≥ÿßÿ± ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸä)
      final userMessagesRef = _firestore
          .collection('users')
          .doc(senderId)
          .collection('chats')
          .doc(receiverId)
          .collection('messages');

      // ÿ¨ŸÑÿ® ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÇÿ®ŸÑ ÿßŸÑÿ≠ÿ∞ŸÅ
      final snapshot = await userMessagesRef.where('id', isEqualTo: messageId).get();
      if (snapshot.docs.isEmpty) {
        print("‚ùå Message not found in Firestore.");
        return;
      }

      final docToDelete = snapshot.docs.first;
      final message = MessageModel.fromMap(docToDelete.data());
      await docToDelete.reference.delete();

      // ÿ≠ÿ∞ŸÅ ŸÖŸÜ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ŸÅŸä ÿßŸÑÿ∞ÿßŸÉÿ±ÿ©
      messages.removeWhere((msg) => msg.id == messageId);

      // ŸÅÿ≠ÿµ ŸÖÿß ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸáŸä ÿßŸÑÿ£ÿÆŸäÿ±ÿ©
      final latestSnapshot = await userMessagesRef
          .orderBy('timestamp', descending: true)
          .limit(1)
          .get();

      final lastMsg = latestSnapshot.docs.isNotEmpty
          ? MessageModel.fromMap(latestSnapshot.docs.first.data())
          : null;

      final wasDeletedLatest = lastMsg == null ||
          message.timestamp.isAtSameMomentAs(lastMsg.timestamp) ||
          message.timestamp.isAfter(lastMsg.timestamp);

      if (wasDeletedLatest) {
        // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ© ÿßŸÑÿ£ÿÆŸäÿ±ÿ© ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸä ŸÅŸÇÿ∑
        final newLastSnapshot = await userMessagesRef
            .orderBy('timestamp', descending: true)
            .limit(1)
            .get();

        final newLast = newLastSnapshot.docs.isNotEmpty
            ? MessageModel.fromMap(newLastSnapshot.docs.first.data())
            : null;

        final preview = switch (newLast?.contentType) {
          'image' => 'Image üñºÔ∏è',
          'video' => 'Video üé•',
          'audio' => 'Audio üéµ',
          _ => newLast?.content ?? '',
        };

        final userChatRef = _firestore
            .collection('users')
            .doc(senderId)
            .collection('chats')
            .doc(receiverId);

        await userChatRef.set({
          'lastMessage': preview,
          'timestamp': newLast != null
              ? Timestamp.fromDate(newLast.timestamp)
              : FieldValue.delete(),
        }, SetOptions(merge: true));

        print("‚úÖ lastMessage updated for current user only to: $preview");
      } else {
        print("‚úÖ Message deleted without updating lastMessage.");
      }
    } catch (e) {
      print("‚ùå Error deleting message locally: $e");
    }
  }





  Future<void> deleteMessageForAll(String messageId, String receiverId) async {
    try {
      final String senderId = box.read('user_id');

      var paths = [
        _firestore
            .collection('users')
            .doc(senderId)
            .collection('chats')
            .doc(receiverId)
            .collection('messages'),
        _firestore
            .collection('users')
            .doc(receiverId)
            .collection('chats')
            .doc(senderId)
            .collection('messages'),
      ];

      for (var path in paths) {
        final snapshot = await path.where('id', isEqualTo: messageId).get();
        for (var doc in snapshot.docs) {
          await doc.reference.delete();
        }
      }

      // ÿ™ÿ≠ÿØŸäÿ´ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ŸÅŸä ÿßŸÑÿ∞ÿßŸÉÿ±ÿ© ŸÅŸÇÿ∑
      messages.removeWhere((msg) => msg.id == messageId);

      // ÿ™ÿ≠ÿØŸäÿ´ lastMessage ŸÅŸä ÿßŸÑÿ∑ÿ±ŸÅŸäŸÜ
      await _updateLastMessageAfterDelete(senderId, receiverId);

    } catch (e) {
      print("‚ùå Error deleting message for all: $e");
    }
  }

  Future<void> _updateLastMessageAfterDelete(String senderId, String receiverId) async {
    try {
      // ÿßŸÑŸÖÿ≥ÿßÿ± ÿ•ŸÑŸâ ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ© (ŸÖŸÜ Firestore)
      final messagesRef = _firestore
          .collection('users')
          .doc(senderId)
          .collection('chats')
          .doc(receiverId)
          .collection('messages');

      // ÿ¨ŸÑÿ® ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ŸÖÿ±ÿ™ÿ®ÿ© ÿ™ŸÜÿßÿ≤ŸÑŸäÿßŸã ÿ≠ÿ≥ÿ® ÿßŸÑŸàŸÇÿ™
      final snapshot = await messagesRef.orderBy('timestamp', descending: true).limit(1).get();

      final lastMsg = snapshot.docs.isNotEmpty
          ? MessageModel.fromMap(snapshot.docs.first.data())
          : null;

      final lastPreview = switch (lastMsg?.contentType) {
        'image' => 'Image üñºÔ∏è',
        'video' => 'Video üé•',
        'audio' => 'Audio üéµ',
        _ => lastMsg?.content ?? '',
      };

      final senderChatRef = _firestore
          .collection('users')
          .doc(senderId)
          .collection('chats')
          .doc(receiverId);

      final receiverChatRef = _firestore
          .collection('users')
          .doc(receiverId)
          .collection('chats')
          .doc(senderId);

      final data = {
        'lastMessage': lastPreview,
        'timestamp': lastMsg != null ? Timestamp.fromDate(lastMsg.timestamp) : FieldValue.delete(),
      };

      await senderChatRef.set(data, SetOptions(merge: true));
      await receiverChatRef.set(data, SetOptions(merge: true));

      print("‚úÖ lastMessage updated to: $lastPreview");
    } catch (e) {
      print("‚ùå Error updating lastMessage: $e");
    }
  }


  Future<void> forwardMessage(MessageModel message) async {
    // Open your contact picker screen or implement logic as needed
    print("Forward message: ${message.content}");
    // You would typically navigate to a screen and call sendMessage from there
  }

// ‚úÖ Step 1: ÿ™ÿπÿØŸäŸÑ ÿØÿßŸÑÿ© editMessage ÿØÿßÿÆŸÑ ChatController
  Future<void> editMessage(MessageModel message, String newContent) async {
    try {
      final senderId = box.read('user_id');
      final receiverId = message.receiverId;

      // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ŸÖÿ§ŸÇÿ™Ÿãÿß ŸÅŸä ÿßŸÑÿ∞ÿßŸÉÿ±ÿ©
      message.content = newContent;

      // ‚úÖ ÿ™ÿπÿØŸäŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÑÿØŸâ ÿßŸÑÿ∑ÿ±ŸÅŸäŸÜ ŸÅŸä Firestore
      for (final path in [
        _firestore
            .collection('users')
            .doc(senderId)
            .collection('chats')
            .doc(receiverId)
            .collection('messages'),
        _firestore
            .collection('users')
            .doc(receiverId)
            .collection('chats')
            .doc(senderId)
            .collection('messages'),
      ]) {
        final snapshot = await path.where('id', isEqualTo: message.id).get();
        for (var doc in snapshot.docs) {
          await doc.reference.update({
            'content': newContent,
          });
        }
      }

      // ‚úÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿØÿßÿÆŸÑ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ŸÅŸä ÿßŸÑÿ∞ÿßŸÉÿ±ÿ©
      int index = messages.indexWhere((m) => m.id == message.id);
      if (index != -1) {
        messages[index].content = newContent;
        messages.refresh();
      }

      // ‚úÖ ÿ™ÿ≠ÿØŸäÿ´ lastMessage ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ Ÿáÿ∞Ÿá ŸáŸä ÿ¢ÿÆÿ± ÿ±ÿ≥ÿßŸÑÿ©
      final lastMessage = messages.isNotEmpty ? messages.last : null;

      if (lastMessage != null && lastMessage.id == message.id) {
        final preview = switch (message.contentType) {
          'image' => 'Image üñºÔ∏è',
          'video' => 'Video üé•',
          'audio' => 'Audio üéµ',
          _ => newContent,
        };

        final update = {
          'lastMessage': preview,
          'timestamp': Timestamp.fromDate(message.timestamp),
        };

        final senderChatRef = _firestore
            .collection('users')
            .doc(senderId)
            .collection('chats')
            .doc(receiverId);

        final receiverChatRef = _firestore
            .collection('users')
            .doc(receiverId)
            .collection('chats')
            .doc(senderId);

        await senderChatRef.set(update, SetOptions(merge: true));
        await receiverChatRef.set(update, SetOptions(merge: true));
      }

    } catch (e) {
      print("‚ùå Error editing message: $e");
    }
  }

  Future<void> replyToMessage(MessageModel message) async {
    // You can set this message as the message being replied to
    print("Reply to message: ${message.content}");
    // Then handle UI display and storage in sendMessage accordingly
  }

  Future<void> pickMedia(
      String senderId, String receiverId, ImageSource source, bool isVideo) async {
    try {
      bool permissionGranted = false;

      if (source == ImageSource.gallery) {
        final status = await Permission.photos.status;
        if (status.isGranted) {
          permissionGranted = true;
        } else {
          final result = await Permission.photos.request();
          permissionGranted = result.isGranted;
        }
      } else if (source == ImageSource.camera) {
        final cameraStatus = await Permission.camera.status;
        if (cameraStatus.isGranted) {
          permissionGranted = true;
        } else {
          final result = await Permission.camera.request();
          permissionGranted = result.isGranted;
        }
      }

      if (!permissionGranted) {
        Get.snackbar("ÿ±ŸÅÿ∂ ÿßŸÑÿ•ÿ∞ŸÜ", "Ÿäÿ±ÿ¨Ÿâ ŸÖŸÜÿ≠ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑŸàÿµŸàŸÑ ŸÑŸÑŸÖÿ™ÿßÿ®ÿπÿ©.");
        return;
      }

      final XFile? mediaFile = isVideo
          ? await _picker.pickVideo(source: source)
          : await _picker.pickImage(source: source);

      if (mediaFile == null) {
        Get.snackbar("ÿ•ŸÑÿ∫ÿßÿ°", "ŸÑŸÖ Ÿäÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± ÿ£Ÿä ŸÖŸÑŸÅ.");
        return;
      }

      File originalFile = File(mediaFile.path);

      if (!await originalFile.exists()) {
        Get.snackbar("ÿÆÿ∑ÿ£", "ÿßŸÑŸÖŸÑŸÅ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ ÿ£Ÿà ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠.");
        return;
      }

      // ‚úÇÔ∏è ŸÑŸà ŸÉÿßŸÜÿ™ ÿµŸàÿ±ÿ©ÿå ÿßŸÅÿ™ÿ≠ ImageCropper
      if (!isVideo) {
        final CroppedFile? cropped = await ImageCropper().cropImage(
          sourcePath: originalFile.path,
          compressFormat: ImageCompressFormat.jpg,
          compressQuality: 100,
          // cropStyle: CropStyle.rectangle,
          uiSettings: [
            AndroidUiSettings(
              toolbarTitle: 'ÿ™ÿπÿØŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ©',
              toolbarColor: Colors.black,
              toolbarWidgetColor: Colors.white,
              // initAspectRatio: CropAspectRatio(ratioX: 1, ratioY: 1),
              lockAspectRatio: false,
            ),
            IOSUiSettings(
              title: 'ÿ™ÿπÿØŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ©',
            ),
          ],
        );

        if (cropped == null) {
          Get.snackbar("ÿ•ŸÑÿ∫ÿßÿ°", "ŸÑŸÖ Ÿäÿ™ŸÖ ŸÇÿµ ÿßŸÑÿµŸàÿ±ÿ©.");
          return;
        }

        originalFile = File(cropped.path); // üîÅ ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑŸÖŸÇÿµŸàÿµÿ©
      }

      print("üì∏ ÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÖŸÑŸÅ: ${originalFile.path}");

      String fileName = DateTime.now().millisecondsSinceEpoch.toString();
      String fileType = isVideo ? "video" : "image";

      final Directory tempDir = await getTemporaryDirectory();
      final String safePath = '${tempDir.path}/$fileName';
      final File safeFile = await originalFile.copy(safePath);

      print("üìÅ ŸÜÿ≥ÿÆÿ© ÿ¢ŸÖŸÜÿ© ŸÖÿ≠ŸÅŸàÿ∏ÿ© ŸÅŸä: $safePath");

      File fileToUpload = safeFile;

      if (!isVideo) {
        final compressedBytes = await FlutterImageCompress.compressWithFile(
          safeFile.absolute.path,
          quality: 70,
          format: CompressFormat.jpeg,
        );

        if (compressedBytes != null) {
          final compressedFile = File('${tempDir.path}/compressed_$fileName.jpg');
          await compressedFile.writeAsBytes(compressedBytes);
          fileToUpload = compressedFile;
          print("üì¶ ÿßŸÑÿ≠ÿ¨ŸÖ ÿ®ÿπÿØ ÿßŸÑÿ∂ÿ∫ÿ∑: ${await compressedFile.length()} bytes");
        } else {
          print("‚ö†Ô∏è ŸÅÿ¥ŸÑ ÿßŸÑÿ∂ÿ∫ÿ∑ÿå ÿ≥Ÿäÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ£ÿµŸÑŸä.");
        }
      }

      String safeSenderId = Uri.encodeComponent(senderId);
      String safeReceiverId = Uri.encodeComponent(receiverId);

      Reference storageRef = FirebaseStorage.instance
          .ref()
          .child("chats/$safeSenderId/$safeReceiverId/$fileName");

      print("üöÄ ÿ®ÿØÿ° ÿßŸÑÿ±ŸÅÿπ ÿ•ŸÑŸâ: chats/$safeSenderId/$safeReceiverId/$fileName");

      UploadTask uploadTask = storageRef.putFile(
        fileToUpload,
        SettableMetadata(
          contentType: isVideo ? 'video/mp4' : 'image/jpeg',
        ),
      );

      TaskSnapshot snapshot = await uploadTask;
      String fileUrl = await snapshot.ref.getDownloadURL();

      print("‚úÖ ÿ™ŸÖ ÿßŸÑÿ±ŸÅÿπ ÿ®ŸÜÿ¨ÿßÿ≠. ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ: $fileUrl");

      await sendMessage(
        senderId,
        receiverId,
        fileUrl,
        fileType,
        replyToStoryUrl: null,
        replyToStoryType: null,
        replyToStoryId: null,
        localPath: safeFile.path,
      );

      Get.snackbar("ÿ™ŸÖ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ", "ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖŸÑŸÅ ÿ®ŸÜÿ¨ÿßÿ≠.");
    } catch (e) {
      print("‚ùå Error picking media: $e");
      Get.snackbar("ÿÆÿ∑ÿ£", "ŸÅÿ¥ŸÑ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖŸÑŸÅ: $e");
    }
  }


  Future<void> markMessagesAsRead(String senderId, String receiverId) async {
    try {
      var messagesRef = _firestore
          .collection('users')
          .doc(receiverId)
          .collection('chats')
          .doc(senderId)
          .collection('messages');

      var snapshot = await messagesRef.where('isRead', isEqualTo: false).get();

      for (var doc in snapshot.docs) {
        await doc.reference.update({'isRead': true});
      }

      await _firestore
          .collection('users')
          .doc(senderId)
          .collection('chats')
          .doc(receiverId)
          .update({
        'unreadMessages': 0,
      });
    } catch (e) {
      print("Error marking messages as read: \$e");
    }
  }

  // Stream<List<MessageModel>> getMessages(String senderId, String receiverId) {
  //   return _firestore
  //       .collection('users')
  //       .doc(senderId)
  //       .collection('chats')
  //       .doc(receiverId)
  //       .collection('messages')
  //       .orderBy('timestamp')
  //       .snapshots()
  //       .map((snapshot) => snapshot.docs
  //       .map((doc) => MessageModel.fromMap(doc.data()))
  //       .toList());
  // }

  Map<String, String?> videoThumbnails = {};

  Future<void> prepareVideoThumbnails(List<MessageModel> messages) async {
    for (final msg in messages) {
      if (msg.contentType == "video" && !videoThumbnails.containsKey(msg.content)) {
        final thumb = await VideoThumbnailCache().getThumbnail(msg.content);
        videoThumbnails[msg.content] = thumb;
      }
    }
  }

  Future<void> generateAndCacheThumbnail(String videoUrl) async {
    if (videoThumbnails.containsKey(videoUrl)) return;

    final safeFileName = md5.convert(utf8.encode(videoUrl)).toString();
    final dir = await getTemporaryDirectory();
    final filePath = '${dir.path}/thumb_$safeFileName.jpg';

    final file = File(filePath);
    if (await file.exists()) {
      videoThumbnails[videoUrl] = filePath;
    } else {
      final thumbnail = await VideoThumbnail.thumbnailFile(
        video: videoUrl,
        thumbnailPath: filePath,
        imageFormat: ImageFormat.JPEG,
        quality: 75,
      );
      if (thumbnail != null) {
        videoThumbnails[videoUrl] = thumbnail;
      }
    }
  }

  Stream<List<MessageModel>> getMediaMessages(String senderId, String receiverId) {
    return _firestore
        .collection('users')
        .doc(senderId)
        .collection('chats')
        .doc(receiverId)
        .collection('messages')
        .where('contentType', whereIn: ['image', 'video', 'audio'])
        .orderBy('timestamp')
        .snapshots()
        .map((snapshot) {
      return snapshot.docs
          .map((doc) => MessageModel.fromMap(doc.data(), docId: doc.id))
          .toList();
    });
  }

}
